"""contains all helper functions used for deap RNN evolution code - all functions
that are not evaluation or part of the evolutionary code
"""

import numpy as np
import torch

def list_to_matrices(weight_list, num_in, num_hid, num_out):
	"""takes a list of weight generated by deap and converts
	it into numpy arrays that can then be entered into PyTorch
	as the parameters for an RNN to judge its fitness

	Assumes each RNN always has two weight matrices
	"""
	
	# define size of first weight matrix
	# size of second weight matrix follows from this
	w1_size = (num_in + num_hid)*num_hid
	w1_bias_size = num_hid
	w2_size = (num_hid*num_out)
	w2_bias_size = num_out
	
	# separate each of the weight into separate numpy arrays
	# resized after - returned now as 1D arrays
	w1 = np.array(weight_list[: w1_size], copy=True)
	w1_bias = np.array(weight_list[w1_size: (w1_size + w1_bias_size)], copy=True)
	w2 = np.array(weight_list[(w1_size + w1_bias_size): (w1_size + w1_bias_size + w2_size)],
			copy=True)
	w2_bias = np.array(weight_list[(w1_size + w1_bias_size + w2_size): ], copy=True)
	
	return (w1, w1_bias, w2, w2_bias)

def inject_weights(rnn, w1, w1_bias, w2, w2_bias):
	"""method that takes a pytorch rnn and sets the
	weights of its two linear units equal to w1 and 
	w2 so that their fitness can be tested with the RNN
	"""
	
	# find needed shapes of weight matrices
	w1_shape = rnn.in2hid.weight.data.numpy().shape
	w1_bias_shape = rnn.in2hid.bias.data.numpy().shape
	w2_shape = rnn.hid2out.weight.data.numpy().shape
	w2_bias_shape = rnn.hid2out.bias.data.numpy().shape	

	# reshape matrices to the proper shape
	w1 = np.reshape(w1, w1_shape)
	w1_bias = np.reshape(w1_bias, w1_bias_shape)
	w2 = np.reshape(w2, w2_shape)
	w2_bias = np.reshape(w2_bias, w2_bias_shape)
	
	# convert numpy arrays to tensors
	w1 = torch.from_numpy(w1).float()
	w1_bias = torch.from_numpy(w1_bias).float()
	w2 = torch.from_numpy(w2).float()
	w2_bias = torch.from_numpy(w2_bias).float()
	
	# set weights within the rnn equal to w1 and w2
	# types of weights must be float to avoid error with double
	rnn.in2hid.weight.data = w1
	rnn.in2hid.bias.data = w1_bias
	rnn.hid2out.weight.data = w2
	rnn.hid2out.bias.data = w2_bias
	
	# set all tensors in the state array equal to new weights
	rnn.state_dict()['in2hid.weight'].copy_(w1)
	rnn.state_dict()['in2hid.bias'].copy_(w1_bias)
	rnn.state_dict()['hid2out.weight'].copy_(w2)
	rnn.state_dict()['hid2out.bias'].copy_(w2_bias)

	# return the rnn with newly set weights
	return rnn

def get_rnn_output(rnn, max_it, act_exp, verbose=False):
	"""takes rnn with current weights and gets all outputs
	for the associated output circle
		

	Parameters:
	rnn -- the rnn being used
	max_it -- the maximum number of discrete points in the helical shape
	sigmoid_exp -- constant to multiply numbers passed into output activation
`	"""
	
	# initialize all tracking values that are needed
	# to create a structure with the rnn
	theta_scale = 20.0
	radius_scale = 4.0
	hidden = torch.zeros(1, rnn.hidden_size)
	all_positions = []
	r = 0.0
	theta = 0.0
	dr = 0.0
	dt = 0.0
	curr_t = 0 # track current t so that it does not exceed max

	# run rnn until candidate structure reaches the origin
	while (curr_t < max_it):
		# add current position into structure history
		rnn_pos = (r, theta)
		all_positions.append(rnn_pos)

		# get input and activate rnn at current timestep
		# be sure to normalize inputs before they are passed into RNN
		rnn_input = [[dr, dt]]
		outs, hidden = rnn.forward(torch.Tensor(rnn_input), hidden, act_exp)
		dr, dt = outs.data[0][0].item(), outs.data[0][1].item()
		
		# thickness should be scaled to minimum thickness and avoid negative thickness
		# tanh has a minimum value of -1, so add this to thickness and the minimum value
		# must also scale range of tanh to output values from min to max thickness
		#thick += (1.0 + MIN_THICKNESS)*((MAX_THICKNESS - MIN_THICKNESS)/2.0)	
	
		# print information
		if verbose:
			print("Current R: {0}".format(str(r)))
			print("dR: {0}".format(str(dr)))
			print("dT: {0}".format(str(dt)))
			#print("Thick: {0}".format(str(thick)))

		# update the current position of the structure
		# outputs are scaled to make changes not as large
		r += dr#(dr/radius_scale)
		theta += dt#abs(dt)/theta_scale

		# increment the current time step
		curr_t += 1

	all_positions.append((r, theta))

	return all_positions

def get_RNN_output_cartesian(rnn, max_y, max_x, max_t, act_exp, verbose=False):
	"""gets RNN output for the gear tooth evolution - output starts at (0,0)
	in cartesian coordinates and moves upwards until it reaches a maximum value
	of y, forming a unique path from bottom to top that will be used as the shape
	of the gear tooth"""

	# intialize all values that need to be tracked by rnn
	x = 0.0
	y = 0.0
	dx = 0.0
	dy = 0.0
	x_scale = 5.0
	y_scale = 5.0
	curr_t = 0

	# initialize hidden state
	hidden = torch.zeros(1, rnn.hidden_size)

	# track all positions of RNN
	all_positions = []
	
	# run RNN until output reaches desired y position
	while(y < max_y and curr_t < max_t):
		# add current position into the positions list
		rnn_pos = (x, y)
		all_positions.append(rnn_pos)

		# form input and activte the rnn
		rnn_input = [[dx, dy]]
		outs, hidden = rnn.forward(torch.Tensor(rnn_input), hidden, act_exp)
		dx, dy = outs.data[0][0].item(), outs.data[0][1].item()

		# print out the dx and dy if it is verbose
		if(verbose):
			print("X: {0}".format(str(x)))
			print("Y: {0}".format(str(y)))
			print("dx: {0}".format(str(dx)))
			print("dy: {0}".format(str(dy)))
			input()

		# update x and y pos with rnn output
		x += (dx/x_scale)
		# x must be kept from going much too far from center
		if(x < -max_x):
			x = -max_x
		elif(x > max_x):
			x = max_x
		y += abs(dy/y_scale) # y must always move upward ? or is it ok?
		curr_t += 1
	
	# append the last position of the RNN
	all_positions.append((x, y))
	return all_positions

def get_gear_mechanism(rnn, max_gears, min_gears, stop_thresh, rad_scale, act_exp, pos_thresh):
	"""method for getting output of RNN representing an entire mechanism of gears
	rnn outputs at each t a value deciding if next gear will be to left, to right,
	or attached to back, and another value dictating the pitch radius of the gear -
	also outputs a value that decides if rnn should stop at this gear"""	


	# initialize all variables needed to get output
	gear_pos = 0
	stop = 0
	radius = 0

	# initialize the hidden layer
	hidden = torch.zeros(1, rnn.hidden_size)	
	
	# length of the outputs is the number of gears that have been added to system
	all_outputs = []

	while((len(all_outputs) < min_gears) or (len(all_outputs) < max_gears and stop < stop_thresh)):
		# must run inputs through RNN first to get values for first gear
		rnn_input = [[radius, gear_pos, stop]]
		outs, hidden = rnn.forward(torch.Tensor(rnn_input), hidden, act_exp)
		radius, gear_pos, stop = outs.data[0][0].item(), outs.data[0][1].item(), outs.data[0][2].item()
	
		'''		
		# make sure the pos does not go from left to right, must be placed on back first
		if(gear_pos < pos_thresh[0] and len(all_outputs) > 0 and all_outputs[-1][1] > pos_thresh[1]):
			gear_pos = pos_thresh[1]
		elif(gear_pos > pos_thresh[1] and len(all_outputs) > 0 and all_outputs[-1][1] < pos_thresh[0]):
			gear_pos = pos_thresh[0]
		'''

		# make sure radius is positive and scale it to fit between 0 and maximum possible value
		radius = (radius + 1.5)*rad_scale	

		# append outputs into list
		all_outputs.append((radius, gear_pos, stop))
	
	return all_outputs

def get_gear_ratio(outputs, pos_thresh):
	"""method for finding the gear ratio of a set of gears that is generated
	by the rnn - assumes that the first gear in the list is the input and
	the last gear in the list is the output"""

	# set radius to the intial value
	radius = outputs[0][0]
	ratio = 1.0	

	# go through each gear and update the ratio by multiplying with current ratio
	for gear_ind in range(1, len(outputs)):
		gear = outputs[gear_ind]
		nxt_radius = gear[0]
		direction = gear[1]
		if(direction < pos_thresh[0] or direction > pos_thresh[1]):
			ratio *= radius/nxt_radius
		# if gear is attached to back only need to update radius
		radius = nxt_radius

	return ratio

def get_centers_and_radii(outputs, pos_thresh, output_min):
	"""takes a list of outputs of form (radius, position output, stop) and
	transforms it into a list of center locations and radii - any values below
	pos_thresh for position output are scaled between 0 and 360 degrees for placement
	relative to the last gear in the list, anything greater or equal represents gear
	being attached to back of previous gear"""

	# find how much positions should be scaled to get to 360
	total_range = pos_thresh + -output_min# range is from -1 to pos thresh for tanh
	scale_factor = 2*np.pi/total_range

	# instantiate resulting list - first circle always at origin
	result = [((0, 0), outputs[0][0])]

	# go through each gear and find position relative to previous gear
	for curr, last in zip(outputs[1:], outputs):
		# if position greater than pos_thresh, gear is attached to back of previous
		if(curr[1] > pos_thresh):
			result.append((result[-1][0], curr[0]))
		else:
			angle = (curr[1] + 1)*scale_factor
			distance = curr[0] + last[0]
			last_pos = result[-1][0]
			
			# must handle each quadrant specifically depending on angle
			if(angle <= np.pi/2.0):
				x_change = distance*np.cos(angle)
				y_change = distance*np.sin(angle)
			elif(angle <= np.pi):
				angle = np.pi - angle
				x_change = -distance*np.cos(angle)
				y_change = distance*np.sin(angle)
			elif(angle <= 1.5*np.pi):
				angle = angle - np.pi
				x_change = -distance*np.cos(angle)
				y_change = -distance*np.sin(angle)
			else:
				angle = 2*np.pi - angle
				x_change = distance*np.cos(angle)
				y_change = -distance*np.sin(angle)
			
			# update the position with change in x and y relative to last pos
			pos = (last_pos[0] + x_change, last_pos[1] + y_change)			
			result.append((pos, curr[0]))
	
	return result

def check_intersect(circles):
	"""takes a list of circles (defined as a tuple with center position and the radii)
	and returns true if any circles intersect and false if not circles intersect"""

	# perform nested loop and check if each pair of circles intersects
	for i in enumerate(circles):
		left_c = i[1]
		right_ind = i[0] + 1
		while(right_ind < len(circles)):
			right_c = circles[right_ind]
			if(left_c[0] != right_c[0]):
					# find distance between centers and sum of radii
					center_dist = np.sqrt(np.square(right_c[0][0] - left_c[0][0]) \
						+ np.square(right_c[0][1] - left_c[0][1]))
					radii_sum = right_c[1] + left_c[1]
					
					# if sum of radii is greater than the distance between centers
					# then these two circles intersect
					if(radii_sum > center_dist):
						return True
			right_ind += 1

	# only reaches this point if no circles intersect
	return False
		


if __name__ == '__main__':
	""" main function for quick tests"""

	gears = [(20.0, 0, 0), (10.0, 0.0, 0), (20.0, 1.6, 0)]
	pos_thresh = (-1.5, 1.5)
	print(get_gear_ratio(gears, pos_thresh))
