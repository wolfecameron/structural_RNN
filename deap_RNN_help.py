"""contains all helper functions used for deap RNN evolution code - all functions
that are not evaluation or part of the evolutionary code
"""

import numpy as np
import torch
from copy import deepcopy

from gear import Gear

def list_to_matrices(weight_list, num_in, num_hid, num_out):
	"""takes a list of weight generated by deap and converts
	it into numpy arrays that can then be entered into PyTorch
	as the parameters for an RNN to judge its fitness

	Assumes each RNN always has two weight matrices
	"""
	
	# define size of first weight matrix
	# size of second weight matrix follows from this
	w1_size = (num_in + num_hid)*num_hid
	w1_bias_size = num_hid
	w2_size = (num_hid*num_out)
	w2_bias_size = num_out
	
	# separate each of the weight into separate numpy arrays
	# resized after - returned now as 1D arrays
	w1 = np.array(weight_list[: w1_size], copy=True)
	w1_bias = np.array(weight_list[w1_size: (w1_size + w1_bias_size)], copy=True)
	w2 = np.array(weight_list[(w1_size + w1_bias_size): (w1_size + w1_bias_size + w2_size)],
			copy=True)
	w2_bias = np.array(weight_list[(w1_size + w1_bias_size + w2_size): (w1_size + \
			w1_bias_size + w2_size + w2_bias_size) ], copy=True)
	
	return (w1, w1_bias, w2, w2_bias)

def inject_weights(rnn, w1, w1_bias, w2, w2_bias):
	"""method that takes a pytorch rnn and sets the
	weights of its two linear units equal to w1 and 
	w2 so that their fitness can be tested with the RNN
	"""
	
	# find needed shapes of weight matrices
	w1_shape = rnn.in2hid.weight.data.numpy().shape
	w1_bias_shape = rnn.in2hid.bias.data.numpy().shape
	w2_shape = rnn.hid2out.weight.data.numpy().shape
	w2_bias_shape = rnn.hid2out.bias.data.numpy().shape	

	# reshape matrices to the proper shape
	w1 = np.reshape(w1, w1_shape)
	w1_bias = np.reshape(w1_bias, w1_bias_shape)
	w2 = np.reshape(w2, w2_shape)
	w2_bias = np.reshape(w2_bias, w2_bias_shape)
	
	# convert numpy arrays to tensors
	w1 = torch.from_numpy(w1).float()
	w1_bias = torch.from_numpy(w1_bias).float()
	w2 = torch.from_numpy(w2).float()
	w2_bias = torch.from_numpy(w2_bias).float()
	
	# set weights within the rnn equal to w1 and w2
	# types of weights must be float to avoid error with double
	rnn.in2hid.weight.data = w1
	rnn.in2hid.bias.data = w1_bias
	rnn.hid2out.weight.data = w2
	rnn.hid2out.bias.data = w2_bias
	
	# set all tensors in the state array equal to new weights
	rnn.state_dict()['in2hid.weight'].copy_(w1)
	rnn.state_dict()['in2hid.bias'].copy_(w1_bias)
	rnn.state_dict()['hid2out.weight'].copy_(w2)
	rnn.state_dict()['hid2out.bias'].copy_(w2_bias)

	# return the rnn with newly set weights
	return rnn

def get_rnn_output(rnn, max_it, act_exp, verbose=False):
	"""takes rnn with current weights and gets all outputs
	for the associated output circle
		

	Parameters:
	rnn -- the rnn being used
	max_it -- the maximum number of discrete points in the helical shape
	sigmoid_exp -- constant to multiply numbers passed into output activation
	"""
	
	# initialize all tracking values that are needed
	# to create a structure with the rnn
	theta_scale = 20.0
	radius_scale = 4.0
	hidden = torch.ones(1, rnn.hidden_size)
	all_positions = []
	r = 0.0
	theta = 0.0
	dr = 0.0
	dt = 0.0
	curr_t = 0 # track current t so that it does not exceed max

	# run rnn until candidate structure reaches the origin
	while (curr_t < max_it):
		# add current position into structure history
		rnn_pos = (r, theta)
		all_positions.append(rnn_pos)

		# get input and activate rnn at current timestep
		# be sure to normalize inputs before they are passed into RNN
		rnn_input = [[dr, dt]]
		outs, hidden = rnn.forward(torch.Tensor(rnn_input), hidden, act_exp)
		dr, dt = outs.data[0][0].item(), outs.data[0][1].item()
		
		# thickness should be scaled to minimum thickness and avoid negative thickness
		# tanh has a minimum value of -1, so add this to thickness and the minimum value
		# must also scale range of tanh to output values from min to max thickness
		#thick += (1.0 + MIN_THICKNESS)*((MAX_THICKNESS - MIN_THICKNESS)/2.0)	
	
		# print information
		if verbose:
			print("Current R: {0}".format(str(r)))
			print("dR: {0}".format(str(dr)))
			print("dT: {0}".format(str(dt)))
			#print("Thick: {0}".format(str(thick)))

		# update the current position of the structure
		# outputs are scaled to make changes not as large
		r += dr#(dr/radius_scale)
		theta += dt#abs(dt)/theta_scale

		# increment the current time step
		curr_t += 1

	all_positions.append((r, theta))

	return all_positions

def get_RNN_output_cartesian(rnn, max_y, max_x, max_t, act_exp, verbose=False):
	"""gets RNN output for the gear tooth evolution - output starts at (0,0)
	in cartesian coordinates and moves upwards until it reaches a maximum value
	of y, forming a unique path from bottom to top that will be used as the shape
	of the gear tooth"""

	# intialize all values that need to be tracked by rnn
	x = 0.0
	y = 0.0
	dx = 0.0
	dy = 0.0
	x_scale = 5.0
	y_scale = 5.0
	curr_t = 0

	# initialize hidden state
	hidden = torch.zeros(1, rnn.hidden_size)

	# track all positions of RNN
	all_positions = []
	
	# run RNN until output reaches desired y position
	while(y < max_y and curr_t < max_t):
		# add current position into the positions list
		rnn_pos = (x, y)
		all_positions.append(rnn_pos)

		# form input and activte the rnn
		rnn_input = [[dx, dy]]
		outs, hidden = rnn.forward(torch.Tensor(rnn_input), hidden, act_exp)
		dx, dy = outs.data[0][0].item(), outs.data[0][1].item()

		# print out the dx and dy if it is verbose
		if(verbose):
			print("X: {0}".format(str(x)))
			print("Y: {0}".format(str(y)))
			print("dx: {0}".format(str(dx)))
			print("dy: {0}".format(str(dy)))
			input()

		# update x and y pos with rnn output
		x += (dx/x_scale)
		# x must be kept from going much too far from center
		if(x < -max_x):
			x = -max_x
		elif(x > max_x):
			x = max_x
		y += abs(dy/y_scale) # y must always move upward ? or is it ok?
		curr_t += 1
	
	# append the last position of the RNN
	all_positions.append((x, y))
	return all_positions

def get_hidden_input(num_r, num_c, hidden_type):
	"""creates a matrix of hidden values that are used as the initial
	hidden values for the rnn, these initital values can be zeroes, ones,
	or generated randomly

	:hidden_type is 'rand' if generated randomly, 'zero' if all zeroes, and
	'one' if all ones
	"""
	
	hid_mat = None
	
	# decide what type of initial hidden matrix to create
	if hidden_type == 'rand':
		# create hidden matrix of random values [-1, 1]
		hid_mat = 2.0*(torch.rand(num_r, num_c) - .5)
	elif hidden_type == 'zero':
		hid_mat = torch.zeros(num_r, num_c)
	elif hidden_type == 'one':
		hid_mat = torch.ones(num_r, num_c)
	else:
			print("The input hidden type is not a valid option - returning None")
	return hid_mat
			

def get_gear_mechanism(rnn, max_gears, min_gears, stop_thresh, rad_scale, act_exp, pos_thresh, hidden_input):
	"""method for getting output of RNN representing an entire mechanism of gears
	rnn outputs at each t a value deciding if next gear will be to left, to right,
	or attached to back, and another value dictating the pitch radius of the gear -
	also outputs a value that decides if rnn should stop at this gear"""	

	# initialize all variables needed to get output
	radius = 1.0
	gear_pos_a = 1.0 # angle gear is placed at
	stop = 1.0

	# initialize the hidden layer
	hidden = get_hidden_input(1, rnn.hidden_size, hidden_input)#torch.zeros(1, rnn.hidden_size)	
	
	# length of the outputs is the number of gears that have been added to system
	all_outputs = []

	while((len(all_outputs) < min_gears) or (len(all_outputs) < max_gears and stop < stop_thresh)):
		# must run inputs through RNN first to get values for first gear
		rnn_input = [[radius, gear_pos_a, stop]]
		outs, hidden = rnn.forward(torch.Tensor(rnn_input), hidden, act_exp)
		radius, gear_pos_a, stop = outs.data[0][0].item(), outs.data[0][1].item() \
												, outs.data[0][2].item()

		# make sure radius is positive and scale it to fit between 0 and maximum possible value
		# do not input scaled value back into RNN - large values can bias the input
		radius_scaled = (radius + 1.5)*rad_scale	
	
		# append outputs into list
		all_outputs.append((radius_scaled, gear_pos_a, stop))
	
	return all_outputs


def get_discrete_gear_mechanism(rnn, num_unique_gears, max_gears, min_gears, stop_thresh, rad_scale, act_exp, pos_thresh, hidden_input):
	"""generates output of RNN to create a gear mechanism, first n outputs of each time step
	represent the probability of each discrete type of gear being present, the one with the highest
	probability is the radius of gear that is present at that time step, there are also two other outputs,
	positition and stop, that dictate where this gear will be placed and if the RNN should continue
	outputting gears"""

	# initialize all variables needed to get output
	rnn_input = torch.ones(1, num_unique_gears + 2)

	# initialize the hidden layer
	hidden = get_hidden_input(1, rnn.hidden_size, hidden_input)	
	
	# length of the outputs is the number of gears that have been added to system
	all_outputs = []

	while((len(all_outputs) < min_gears) or (len(all_outputs) < max_gears and stop < stop_thresh)):
		# run next forward propogation
		outs, hidden = rnn.forward_softmax(rnn_input, hidden, num_unique_gears, act_exp)
		# output of this step becomes input for next step
		rnn_input = outs
		stop = outs.data[0][num_unique_gears+1].item()	

		# get the current gear type/size	
		gear_type = np.argmax(outs.data[0][:num_unique_gears].numpy())

		# append outputs into list
		all_outputs.append((gear_type, outs.data[0][num_unique_gears].item(), outs.data[0][num_unique_gears+1].item()))
	
	return all_outputs


def get_gear_ratio(outputs, pos_thresh):
	"""method for finding the gear ratio of a set of gears that is generated
	by the rnn - assumes that the first gear in the list is the input and
	the last gear in the list is the output"""

	# set radius to the intial value
	radius = outputs[0][0]
	ratio = 1.0	

	# go through each gear and update the ratio by multiplying with current ratio
	for gear_ind in range(1, len(outputs)):
		gear = outputs[gear_ind]
		nxt_radius = gear[0]
		direction = gear[1]
		if(direction < pos_thresh[0] or direction > pos_thresh[1]):
			ratio *= radius/nxt_radius
		# if gear is attached to back only need to update radius
		radius = nxt_radius

	return ratio

def get_centers_and_radii(outputs, pos_thresh, output_min):
	"""takes a list of outputs of form (radius, position output, stop) and
	transforms it into a list of center locations and radii - any values below
	pos_thresh for position output are scaled between 0 and 360 degrees for placement
	relative to the last gear in the list, anything greater or equal represents gear
	being attached to back of previous gear
	
	each element of result has form (position, radius, z_position)
	"""

	# find how much positions should be scaled to get to 2*pi
	total_range = pos_thresh - output_min # range is from -1 to pos thresh for tanh
	scale_factor = 2*np.pi/total_range

	# third element of position tuple is a z dimension that tells you if gear is attached to back of another
	z = 0	
	
	# instantiate resulting list - first circle always at origin
	result = [((0, 0), outputs[0][0], z)]

	# go through each gear and find position relative to previous gear
	for curr, last in zip(outputs[1:], outputs):
		# if position greater than pos_thresh, gear is attached to back of previous
		if(curr[1] > pos_thresh):
			# increment z because gears are now placed behind the others
			z += 1
			result.append((result[-1][0], curr[0], z))
		
		else:
			angle = (curr[1] - output_min)*scale_factor
			distance = curr[0] + last[0]
			last_pos = result[-1][0]
			
			# must handle each quadrant specifically depending on angle
			if(angle <= np.pi/2.0):
				x_change = distance*np.cos(angle)
				y_change = distance*np.sin(angle)
			elif(angle <= np.pi):
				angle = np.pi - angle
				x_change = -distance*np.cos(angle)
				y_change = distance*np.sin(angle)
			elif(angle <= 1.5*np.pi):
				angle = angle - np.pi
				x_change = -distance*np.cos(angle)
				y_change = -distance*np.sin(angle)
			else:
				angle = 2*np.pi - angle
				x_change = distance*np.cos(angle)
				y_change = -distance*np.sin(angle)
			
			# update the position with change in x and y relative to last pos
			pos = (last_pos[0] + x_change, last_pos[1] + y_change)			
			result.append((pos, curr[0], z))
	
	return result

def check_intersect_amount(mechanism):
	"""takes a list of circles (defined as a tuple with center position and the radii)
	and returns a sum of the amount of intersecting radius within the mechanism - two
	gears are overlapping if they are in the same z dimension and would collide with each
	other"""

	# perform nested loop and check if each pair of circles intersects
	total_intersection = 0.0
	for i in enumerate(mechanism):
		left_c = i[1]
		right_ind = i[0] + 1
		while(right_ind < len(mechanism)):
			# grab current circle to test for intersection
			right_c = mechanism[right_ind]
			
			# find distance between centers and sum of radii
			center_dist = np.sqrt(np.square(right_c.pos[0] - left_c.pos[0]) \
				+ np.square(right_c.pos[1] - left_c.pos[1]))
			radii_sum = right_c.radius + left_c.radius
			
			# if sum of radii is greater than the distance between centers
			# then these two circles intersect if at same z position
			if(radii_sum > center_dist and left_c.pos[2] == right_c.pos[2]):
				total_intersection += np.square(radii_sum - center_dist)
			right_ind += 1

	# only reaches this point if no circles intersect
	return total_intersection

def check_intersect(mechanism):
	"""takes a list of circles (defined as a tuple with center position and the radii)
	and returns true if any circles intersect and false if not circles intersect"""

	# perform nested loop and check if each pair of circles intersects
	for i in enumerate(mechanism):
		left_c = i[1]
		right_ind = i[0] + 1
		while(right_ind < len(mechanism)):
			# grab current circle to test for intersection
			right_c = mechanism[right_ind]
			
			# find distance between centers and sum of radii
			center_dist = np.sqrt(np.square(right_c.pos[0] - left_c.pos[0]) \
				+ np.square(right_c.pos[1] - left_c.pos[1]))
			radii_sum = right_c.radius + left_c.radius
			
			# if sum of radii is greater than the distance between centers
			# then these two circles intersect if at same z position
			if(radii_sum > center_dist and left_c.pos[2] == right_c.pos[2]):
				return True
			right_ind += 1

	# only reaches this point if no circles intersect
	return False

def check_conflicting_gear_axis(mechanism, hole_size):
	"""finds the amount of overlapping radius of gear mechanisms that cannot be created
	because the center axis of the gear would intersect with the body of another gear

	:param hole_size: the size of the hole that runs through center of gears

	:returns: the amount of overlap that is created by conflicting axis
	"""

	# store the total numeric value for conflicting gear axis
	total_conflict = 0.0
	for l_ind in range(len(mechanism)):
		center = mechanism[l_ind].pos[0]
		rad = mechanism[l_ind].radius
		for r_ind in range(len(mechanism)):
			# check for axis conflicts with every possible pair of gears
			if(l_ind != r_ind):
				o_center = mechanism[r_ind].pos[0]
				left_bound = center - rad - hole_size
				right_bound = center + rad + hole_size		
				if(left_bound <= o_center < center):
					total_conflict += np.square(o_center - left_bound)
				elif(center < o_center <= right_bound):
					total_conflict += np.square(right_bound - o_center)
	return total_conflict

def create_mechanism_representation(all_outputs, pos_thresh, output_min):
	"""uses a list of gear RNN outputs to create a more understandable representation for
	the mechanism, each gear is represented with (radius, position, previous gear, next gears,
	ratio) so that all information for each gear in the mechanism is readily available
	
	this method converts the raw RNN output into the above form - stored as a Gear object
	"""
	
	# populate mechanism with the first gear
	# ratio set to 1.0 by default when gear is instantiated
	r = all_outputs[0][0]
	init_x = np.cos(np.pi/4)*r
	init_y = np.sin(np.pi/4)*r
	mechanism = [Gear(r, (init_x, init_y, 0), 0)]
	
	# go through all outputs and create a gear object for each one
	for index, curr in enumerate(all_outputs[1:]):
		prev_gear = mechanism[-1] # previous gear is always last outputted mechanism
		
		# must set padding to true if space should be inserted between gears for 3D printing
		new_pos = get_gear_pos_linear(prev_gear.pos, curr[1], prev_gear.radius, curr[0],
					pos_thresh, output_min)
		mechanism.append(Gear(curr[0], new_pos, len(mechanism) - 1))
		
		# add index of current into list of nxt gears for gear it attaches to
		prev_gear.next_gears.append(index + 1)
		
		# find ratio of current gear - only changes if not attached to front/back
		new_ratio = prev_gear.ratio*(prev_gear.radius/mechanism[-1].radius)
		if(-pos_thresh <= curr[1] <= pos_thresh ):
			mechanism[-1].ratio = new_ratio
		else:
			mechanism[-1].ratio = prev_gear.ratio

	return mechanism	

def create_discrete_mechanism(all_outputs, gear_radii, pos_thresh, output_min):
	"""creates mechanism using RNN output based on discrete gear radius
	options
	
	:param all_outputs: the list of outputs created by RNN
	:param gear_radii: the list of gear radius options
	"""

	r = gear_radii[all_outputs[0][0]]
	mechanism = [Gear(r, (r, r, 0), 0)]
	for index, curr in enumerate(all_outputs[1:]):
		prev_gear = mechanism[-1]

		# get position for the next gear
		new_pos = get_gear_pos_linear(prev_gear.pos, curr[1], prev_gear.radius, gear_radii[curr[0]], \
				pos_thresh, output_min)
		mechanism.append(Gear(gear_radii[curr[0]], new_pos, len(mechanism) - 1))
		prev_gear.next_gears.append(index + 1)

		# find ratio of the current gear
		new_ratio = prev_gear.ratio*(prev_gear.radius/mechanism[-1].radius)
		if(-pos_thresh <= curr[1] <= pos_thresh ):
			mechanism[-1].ratio = new_ratio
		else:
			mechanism[-1].ratio = prev_gear.ratio

	return mechanism	


def find_novelty(curr_vec, other_vecs, k=1):
	"""pass in a numpy vector characterizing gear mechanism and find the average distance between
	it and all other vectors in matrix other_vecs - returns average distance from the rest
	of the vectors
	
	Paramters
	curr_vec: the vector for which novelty is being found
	other_vecs: all other vectors in the population
	k: the number of distances for which average is being taken
	"""
	
	# find difference between elements of vector and all other vectors
	# square difference to avoid negative values
	difference = other_vecs - curr_vec
	difference = np.square(difference)

	# find total difference for each vector and grab average of values
	summed_rows = np.sum(difference, axis=1)	
	summed_rows = np.reshape(summed_rows, (1, -1))
	sorted_dists = np.sort(summed_rows[0, :])

	# take average of k closest solutions, disclude the first element because it is dist from self
	avg_dist = np.mean(sorted_dists[: k])
	return avg_dist

def get_mechanism_vector(mechanism):
	"""this method creates a charactaristic vector to describe a mechanism
	based on positioning, ratios, and size"""
	
	# create lists that can be populated with all mechanism data
	x = []
	#z = []
	r = []
	total_gear = len(mechanism)
	
	# populate all of the lists
	for gear in mechanism:
		x.append(gear.pos[0])
		#z.append(gear.pos[2])
		r.append(gear.radius)
	
	# convert arrays to np arrays
	x = np.array(x)
	#z = np.array(z)
	r = np.array(r)

	# find the average ratio between each gear
	ratios = np.array([1.0])
	if(len(mechanism) > 1):
		ratios = (r[:-1]/r[1:])
	

	# construct the vector of items to characterize mechanism
	vec = np.array([np.mean(x), np.var(x), np.mean(ratios), np.var(ratios), \
					np.mean(r), np.var(r), len(mechanism)])
	
	return vec					

def get_gear_pos(previous_pos, angle, prev_rad, curr_rad, pos_thresh, output_min, padding=1.0):
	"""this method outputs the position of a single gear based on the position
	of the gear it attaches to and it's angular RNN output
	"""
	
	# find how much positions should be scaled to get to 2*pi
	total_range = -2.0*(1.0 - pos_thresh) - 2.0*output_min # range is from -pos_thresh to pos thresh for tanh
	scale_factor = 2.0*np.pi/total_range
	
	# attack to the back of the previous gear
	if(angle > pos_thresh):
		# just increment z dimension
		pos = (previous_pos[0], previous_pos[1], previous_pos[2] + 1)
	# attach to front of previous gear
	elif(angle < -pos_thresh):
		# just decrement z dimension
		pos = (previous_pos[0], previous_pos[1], previous_pos[2] - 1)	
	
	else:
		angle = (angle + pos_thresh)*scale_factor
		distance = curr_rad + prev_rad
			
		# must handle each quadrant specifically depending on angle
		if(angle <= np.pi/2.0):
			x_change = distance*np.cos(angle)
			y_change = distance*np.sin(angle)
		elif(angle <= np.pi):
			angle = np.pi - angle
			x_change = -distance*np.cos(angle)
			y_change = distance*np.sin(angle)
		elif(angle <= 1.5*np.pi):
			angle = angle - np.pi
			x_change = -distance*np.cos(angle)
			y_change = -distance*np.sin(angle)
		else:
			angle = 2*np.pi - angle
			x_change = distance*np.cos(angle)
			y_change = -distance*np.sin(angle)
		
		# update the position with change in x and y relative to last pos
		pos = (previous_pos[0] + x_change, previous_pos[1] + y_change, previous_pos[2])
		
		# add space between gear centers in x-y dimensions if padding set to true
		# makes 3D printing easier by separating gears more
		pos = (pos[0]*padding, pos[1]*padding, pos[2])

	return pos			


def get_gear_pos_linear(previous_pos, angle, prev_rad, curr_rad, pos_thresh, output_min, padding=1.0):
	"""this method outputs the position of a single gear based on the position
	of the gear it attaches to and it's angular RNN output - instead of placing at any
	angle around previous gear, this method places it linearly to the right of previous
	gear or fixes it to front or back

	return: a tuple (x, y, z) that gives position of gear
	"""
	
	# attack to the back of the previous gear
	if(angle > pos_thresh):
		# just increment z dimension
		pos = (previous_pos[0], previous_pos[1], previous_pos[2] + 1)
	# attach to front of previous gear
	elif(angle < -pos_thresh):
		# just decrement z dimension
		pos = (previous_pos[0], previous_pos[1], previous_pos[2] - 1)	
	# place gear to the right of previous	
	else:
		x_delta = curr_rad + prev_rad
		# update the position with change in x and y relative to last pos
		pos = ((previous_pos[0] + x_delta)*padding, previous_pos[1], previous_pos[2])
		
	return pos			

def check_bounding_box(ind, x_bound, y_bound):
	"""finds the total amount of gears that lie out of the desired boudning
	box for gear system and adds all x and y distances outside of the desired
	bounding box
	"""
	
	# find lowest allowed x and y values
	lower_x = ind[0].pos[0] - ind[0].radius
	lower_y = ind[0].pos[1] - ind[0].radius

	# only check individuals after the first
	total_outside = 0.0
	for g in ind[1:]:
		r = g.radius
		# find the amount the gear lies out of x bound
		x = g.pos[0]
		if((x - r) < lower_x):
			total_outside += np.square((x - r) - lower_x)
		elif((x + r) > x_bound):
			total_outside += np.square((x + r) - x_bound)
		
		# find the amount the gear lies out of y bound
		y = g.pos[1]
		if((y - r) < lower_y):
			total_outside += np.square((y - r) - lower_y)
		elif((y + r) > y_bound):
			total_outside += np.square((y + r) - y_bound)
	return total_outside

def dominates(ind1, ind2):
	"""outputs true if ind1 dominates ind2, false o/w"""

	# get fitness vectors for each individual
	one_fit = ind1.fitness.values
	two_fit = ind2.fitness.values

	# feasible solutions dominate infeasible solutions
	if(one_fit[2] <= 0 and two_fit[2] > 0):
		return True
	
	# if both infeasible dominates if CV is less than other
	# if CV less than other, other must be nonzero!
	elif(one_fit[2] < two_fit[2]):	
		return True
	
	# if both feasible check for traditional domination
	elif(one_fit[2] <= 0 and two_fit[2] <= 0):
		# minimize hidden nodes and maximize novelty
		if(one_fit[0] > two_fit[0] and one_fit[1] < two_fit[1]):
			return True
	
	# only reaches this point if doesn't dominate
	return False

def get_crowding_distance(ind1, ind2):
	"""finds the crowding distance between two individuals
	based on the first two values in fitness vector"""
	
	crowd_dist = 0.0
	crowd_dist += np.square(ind1.fitness.values[0] - ind2.fitness.values[0])
	crowd_dist += np.square(ind1.fitness.values[1] - ind2.fitness.values[1])
	return crowd_dist

def get_3DP_layout(mechanism, bed_width, padding_ratio):
	"""takes a list of gears (mechanism) and alters the positions of the gears
	to be placed into a grid for easy 3D printing

	bed_width: size of the 3D printing bed, used to configure how the gears are
	laid out in a grid to fit on the 3D printer
	padding_ratio: the amount to multiply the distance between gears by to create
	enough padding between them to 3D print
	
	return: both old and newly positioned mechanism lists
	"""
	
	# create a deepcopy of the original mechanism to return
	og_mech = deepcopy(mechanism)
	
	# find maximum radius of all gears
	max_r = max(mechanism, key=lambda g: g.radius).radius
	
	ind = 1
	x = padding_ratio*mechanism[ind - 1].radius
	y = padding_ratio*max_r
	# update position to new 3DP position
	mechanism[ind - 1].pos = (x, y, 0)
	# place each gear from mechanism into a grid
	while(ind < len(mechanism)):
		curr_rad = mechanism[ind].radius
		prev_rad = mechanism[ind - 1].radius
		x_delta = padding_ratio*(curr_rad + prev_rad)
		
		# continue adding gear in current row
		if((x_delta + x + curr_rad) < bed_width):
			x += x_delta
			mechanism[ind].pos = (x, y, 0)
		# create new row for gears
		else:
			x = padding_ratio*mechanism[ind].radius
			y += padding_ratio*2*max_r
			mechanism[ind].pos = (x, y, 0)
		ind += 1
	
	return (mechanism, og_mech)
		
def get_mech_and_vec(ind, rnn, num_in, num_out, num_unique_gears, max_gears, min_gears, stop_threshold,
		radius_scale, act_exp, placement_thresh, gear_radii, output_min):
	"""takes in a set of weights, uses it to activate and rnn and returns the
	outputs, mechanism, and vector for that set of weights"""

	# get rnn output with weights from ind
	w1, w1_bias, w2, w2_bias = list_to_matrices(ind, num_in, ind.h_nodes, num_out)
	rnn = inject_weights(rnn, w1, w1_bias, w2, w2_bias)
	output = get_output(rnn, num_unique_gears, max_gears, min_gears, stop_threshold, \
				radius_scale, act_exp, placement_thresh, 'one')
	
	# generate vector and mechanism representation for rnn output
	mech = create_discrete_mechanism(output, GEAR_RADII, PLACEMENT_THRESH, OUTPUT_MIN)
	vec = get_mechanism_vector(mech)

	return (output, mech, vec)
	
		
	
if __name__ == '__main__':
	""" main function for quick tests"""

	get_gear_pos(None, None, .75, -1)
